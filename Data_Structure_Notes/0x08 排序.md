# 0x08 排序

## 七、堆排序

#### 堆的定义

- 堆是一个顺序存储的完全二叉树。父结点大于孩子结点的堆为大根堆，根结点是堆中元素的最大值；父结点小于孩子结点的堆是小根堆，根结点是堆中元素的最小值。
- 堆排序：先将待排序的数组整理成堆，再输出排好的数组

#### 堆的构建

1. 检查数组中的非终端结点（即$i≤\lfloor n/2\rfloor$的结点，数组的左半部分）是否满足堆的要求
2. 若不满足，将当前结点与它更大的一个孩子互换
3. 若元素互换破坏了下一级的堆，则采用相同的方法继续向下调整
4. 重复以上过程，直到所有非终端结点调整完成

```c++
void BuildMaxHeap(int A[], int len) {
	for (int i = len / 2; i > 0; i--) {
		HeadAdjust(A, i, len);
	}
}

//将以k为根的子树调整为大根堆
//由于调整过程是根结点不断下沉直到满足大根堆要求的过程，
//因此只需要记录根结点的值（A[0]）并追踪它的可能位置（下标k）
void HeadAdjust(int A[], int k, int len) {
	A[0] = A[k]; //A[0]暂存子树的根结点
	for (int i = 2 * k; i <= len; i *= 2) { //i*=2即进入到树的下一层
		if (i < len && A[i] < A[i + 1]) { //先默认选左孩子，发现右孩子存在且更大再选右孩子
			i++; //取更大的子结点的下标
		}
		if (A[0] >= A[i]) break;
        //如果根结点比当前位置k更大的孩子还要大，则满足大根堆要求，应该存放在当前位置
		else {
			A[k] = A[i];  //与根结点互换
			k = i;		//先假设根结点可以存放在下标i中，继续向下看是否符合要求
		}
	}
	//如果跳出了循环，要么i已经>len，即k这个位置已经是叶子结点
	//要么k这个位置符合大根堆要求
	A[k] = A[0]; //k这个位置符合要求
}
```

#### 基于堆的排序

假设数组`A`下标从1开始，`A[n]`为最末尾的元素

1. 每次从堆顶（`A[1]`）获得当前大根堆中最大的元素，然后将`A[1]`与`A[n]`交换
2. 交换后将`A[n]`视为已删除，余下的元素构成新堆，**该堆需要重新调整**，恢复成大根堆
3. 重复上述步骤，直到所有元素均处理完毕

```c++
void HeapSort(int A[], int len) {
	BuildMaxHeap(A, len);
	for (int i = len; i > 1; i--) {
		swap(A[i], A[1]);
		HeapAdjust(A, 1, i - 1);
	}
}
```

#### 算法效率分析

- 建堆过程

  1个结点，每下坠1层，最多只需对比关键字2次（左右孩子比较一次，父节点与孩子比较一次）

  若树高为h，某结点在第i层，则这个结点最多下坠 h-i 层， 关键字对比次数最多 2(h-i)

  完全二叉树的树高 h 与结点数 n 的关系为$h = \lfloor \log_2{n}\rfloor+1$

  第 i 层最多有 $2^{i-1}$个结点，而只有第$1$到第$h-1$层的结点才需要下坠

  因此所有结点的关键字对比次数最多不超过——
  $$
  \sum^1_{i=h-1}{2^{i-1}2(h-i)}=1\times2(h-1) + 2\times2(h-2)+...+2^{h-2}\times2(h-2)
  $$
  整理可得建堆过程中关键字对比次数不超过$4n$，建堆时间复杂度$=O(n)$	

- 排序过程

  每一趟排序，根结点最多下坠$h-1$层，故每趟排序复杂度不超过$O(log_2n)$

- 总的时间复杂度为 $O(n)+O(nlog_2n)=O(nlog_2n)$

  总的空间复杂度为 $O(1)$（全过程都是原地操作）

- 稳定性

  **堆排序是不稳定的**





