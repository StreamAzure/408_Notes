# 0x08 排序

## 一、排序的基本概念

- 排序算法的稳定性：指相同关键字的元素在经过排序算法多次处理后，其相对位置是否保持不变。若保持不变，则称排序算法是稳定的，否则是不稳定的
  - 不能说稳定的排序算法就一定比不稳定的好，应该看实际应用场景。
- 内部排序/外部排序：
  - 内部排序：数据全在内存中。关注点为算法的时间复杂度、空间复杂度
  - 外部排序：数据太多，无法全部放入内存，有些在磁盘上。关注点除了算法的时空复杂度外，还要关注如何使读/写磁盘次数更少。

## 二、插入排序

### 2.1 直接插入排序

```c++
//下标从0开始
void InsertSort(int A[], int n){
	for(int i = 1; i< n;i ++){
        if(A[i] < A[i-1]){
            int temp = A[i];
            int j;
            for(j = i-1; j>=0 && temp < A[j]; j--){ 
                //把前面已有序的部分全部后移一位
                A[j+1] = A[j];
            }
            A[j+1] = temp; //将元素插入到有序部分
        }
    }
}
```

- 空间复杂度：$O(1)$
- 时间复杂度：
  - 最好情况：要求升序排列，且原本就是升序排列。只需要n-1次关键字比对，不需要移动元素，$O(n)$
  - 最坏情况：要求升序排列，而原本是降序排列。$O(n^2)$
- 稳定性：稳定，因为找插入位置的时候是依次处理的，在前面的相同元素一定排在前面，后续的相同元素一定排在后面。

### 2.2 折半插入排序

先用折半查找在已经有序的部分找到应该插入的位置，再移动元素。

为了保证算法稳定性，当`A[mid]==A[0]`时（即数组中存在相同元素），固定在`mid`所指位置的后面/右边寻找插入位置（从而保证后面处理的相同元素一定会放在早前处理的相同元素后面）。

```c++
//数组下标从1开始，A[0]用于临时存放当前处理的元素
void InsertSort(int A[], int n){
	for(int i = 2; i <= n; i++){
		A[0] = A[i];
        int low = 1;
        int high = i-1;
        while(low <= high){
            int mid = (low+high)/2;
            if(A[mid] > A[0]) high = mid-1;
            else low = mid+1; //A[mid] == A[0]时也是low=mid+1
        }//结束循环时low在high的右边一位
        for(int j = i - 1; j >= low; j--){
            A[j+1] = A[j]; //在插入位置上及后面的元素全部后移一位
        }
        A[low] = A[0];
    }
}
```

- 只能减少关键字比对次数，整体时间复杂度仍是$O(n^2)$

## 三、希尔排序

设一个间隔序列（从大到小）$d_1$，$d_2$，$d_3...$，开始时取间隔$d_1$，让待排序表以该间隔划分为若干个子表，如子表1：$A[1],A[1+d_1],A[1+2d_1],...$、子表2：$A[2],A[2+d_2],A[2+d_2],...$。分别对这些子表进行直接插入排序。然后取下一个间隔$d_2$，重复以上操作，直到最后一个间隔$d_n=1$，即对整个表直接进行插入排序。



## 七、堆排序

#### 堆的定义

- 堆是一个顺序存储的完全二叉树。父结点大于孩子结点的堆为大根堆，根结点是堆中元素的最大值；父结点小于孩子结点的堆是小根堆，根结点是堆中元素的最小值。
- 堆排序：先将待排序的数组整理成堆，再输出排好的数组

#### 堆的构建

1. 检查数组中的非终端结点（即$i≤\lfloor n/2\rfloor$的结点，数组的左半部分）是否满足堆的要求
2. 若不满足，将当前结点与它更大的一个孩子互换
3. 若元素互换破坏了下一级的堆，则采用相同的方法继续向下调整
4. 重复以上过程，直到所有非终端结点调整完成

```c++
void BuildMaxHeap(int A[], int len) {
	for (int i = len / 2; i > 0; i--) {
		HeadAdjust(A, i, len);
	}
}

//将以k为根的子树调整为大根堆
//由于调整过程是根结点不断下沉直到满足大根堆要求的过程，
//因此只需要记录根结点的值（A[0]）并追踪它的可能位置（下标k）
void HeadAdjust(int A[], int k, int len) {
	A[0] = A[k]; //A[0]暂存子树的根结点
	for (int i = 2 * k; i <= len; i *= 2) { //i*=2即进入到树的下一层
		if (i < len && A[i] < A[i + 1]) { //先默认选左孩子，发现右孩子存在且更大再选右孩子
			i++; //取更大的子结点的下标
		}
		if (A[0] >= A[i]) break;
        //如果根结点比当前位置k更大的孩子还要大，则满足大根堆要求，应该存放在当前位置
		else {
			A[k] = A[i];  //与根结点互换
			k = i;		//先假设根结点可以存放在下标i中，继续向下看是否符合要求
		}
	}
	//如果跳出了循环，要么i已经>len，即k这个位置已经是叶子结点
	//要么k这个位置符合大根堆要求
	A[k] = A[0]; //k这个位置符合要求
}
```

#### 基于堆的排序

假设数组`A`下标从1开始，`A[n]`为最末尾的元素

1. 每次从堆顶（`A[1]`）获得当前大根堆中最大的元素，然后将`A[1]`与`A[n]`交换
2. 交换后将`A[n]`视为已删除，余下的元素构成新堆，**该堆需要重新调整**，恢复成大根堆
3. 重复上述步骤，直到所有元素均处理完毕

```c++
void HeapSort(int A[], int len) {
	BuildMaxHeap(A, len);
	for (int i = len; i > 1; i--) {
		swap(A[i], A[1]);
		HeapAdjust(A, 1, i - 1);
	}
}
```

#### 算法效率分析

- 建堆过程

  1个结点，每下坠1层，最多只需对比关键字2次（左右孩子比较一次，父节点与孩子比较一次）

  若树高为h，某结点在第i层，则这个结点最多下坠 h-i 层， 关键字对比次数最多 2(h-i)

  完全二叉树的树高 h 与结点数 n 的关系为$h = \lfloor \log_2{n}\rfloor+1$

  第 i 层最多有 $2^{i-1}$个结点，而只有第$1$到第$h-1$层的结点才需要下坠

  因此所有结点的关键字对比次数最多不超过——
  $$
  \sum^1_{i=h-1}{2^{i-1}2(h-i)}=1\times2(h-1) + 2\times2(h-2)+...+2^{h-2}\times2(h-2)
  $$
  整理可得建堆过程中关键字对比次数不超过$4n$，建堆时间复杂度$=O(n)$	

- 排序过程

  每一趟排序，根结点最多下坠$h-1$层，故每趟排序复杂度不超过$O(log_2n)$

- 总的时间复杂度为 $O(n)+O(nlog_2n)=O(nlog_2n)$

  总的空间复杂度为 $O(1)$（全过程都是原地操作）

- 稳定性

  **堆排序是不稳定的**





