# 0x05 树与二叉树

## 一、基本术语

- 空树：结点数为0的树
- 非空树
  - 有且仅有一个根节点
  - 没有后继的结点称为叶子结点
  - 有后继的结点称为分支节点
  - 除根节点外，每个结点有且仅有一个前驱
- 两个结点之间的路径：从上往下
- 路径长度：路径经过了几条边
- 树的路径长度：从根结点出发到各个结点的路径长度之**和**

- 结点的层次（深度）——从上往下数（从1开始，根结点的深度是1）
- 结点的高度——从下往上数（从1开始，叶子结点的高度是1）
- 树的高度/深度——总共多少层
- 结点的度——有几个孩子
- 有序树——各子树从左到右是有顺序的，互换会影响含义
- 无序树——各子树无顺序，可以互换

## 二、树的性质

- 结点数=度数+1
- 树的度——各结点的度的最大值
- m叉树——每个结点**最多**只能有m个孩子的树

| 度为m的树                       | m叉树                         |
| ------------------------------- | ----------------------------- |
| 任意结点的度≤m（最多m个孩子）   | 任意结点的度≤m（最多m个孩子） |
| 至少有一个结点度=m（有m个孩子） | 允许所有结点的度都＜m         |
| 一定是非空树，至少有m+1个结点   | 可以是空树                    |

| 高度为h、度为m的树    | 高度为h的m叉树                                               |
| --------------------- | ------------------------------------------------------------ |
| **至少**有h+m-1个结点 | **至多**有$\frac{m^h-1}{m-1}$个结点（$=m^0+m^1+m^2+...$）<br>**至少**有h个结点 |

- 具有n个结点的m叉树的最小高度为$\lceil \log_m{(n(m-1)+1)}\rceil$

  - 推导：

  $$
  \begin{align}
  &\frac{m^{h-1}-1}{m-1}<n≤\frac{m^h-1}{m-1}\\
  &\Rightarrow m^{h-1}<n(m-1)+1≤mh\\
  &\Rightarrow h-1<\log_m{(n(m-1)+1)}≤h\\
  &\Rightarrow h_{min}=\lceil\log_m({n(m-1)+1)}\rceil&
  \end{align}
  $$

## 三、 二叉树

### 3.1 二叉树的基本特点

#### 二叉树

- 空二叉树，n=0
- 由一个根节点、左子树、右子树构成，左子树、右子树又分别是二叉树

#### 二叉树的特点

- 每个结点至多有两棵子树
- 左右子树不能颠倒（有序树）

#### 二叉树与度为2的有序树的区别

- 度为2的有序树至少有3个结点，而二叉树可以有2个、1个甚至0个结点

### 3.2 二叉树的性质

1. 设非空二叉树中共有$n$个结点，度为0、1、2的结点个数分别为$n_0$、$n_1$、$n_2$，则
   - $n_0=n_2+1$。（1个二分支结点能长出2个叶子，3个二分支结点能长出4个叶子……）
   - $n=n_0+n_1+n_2$
   - $n=n_1+2n_2+1$（$总度数=n_1+2n_2$）
2. 二叉树的第$i$层至多有$2^{i-1}$个结点
3. 高度为$h$的二叉树至多有$2^h-1$个结点（满二叉树的情况）
4. 具有$n$个结点的完全二叉树的高度$h$为$\lceil\log_2{n+1}\rceil$或$\lfloor \log_2{n}\rfloor$

### 3.3 特殊的二叉树

#### 做题常用

- 完全二叉树第 i 层有 m 个叶子结点——当第 i 层是最后一层时结点总数最少，当第 i 层是倒数第二层时结点总数最多
- 完全二叉树共有 m 个叶子结点——当倒数第二层的最左侧的叶子结点有一个左孩子时（这不会改变叶子结点总数），结点总数最多；反之最少。（或通过度数与结点数的关系分析）
- 已知一棵有2011个结点的树，其叶节点个数是116，该树对应的二叉树中无右孩子的结点个数是——这题考点是树转二叉树，左孩子右兄弟。树要构造最特殊的，即一条链的末尾接116个孩子结点。按左孩子右兄弟转为二叉树后变成一条中间有转折的链，前1895个结点无右孩子，链的最末尾结点也无右孩子。故答案为1895+1=1896

#### 满二叉树

- 一棵高为$h$，且含有$2^h-1$个（$2^0+2^1+...+2^h=\frac{1-2^h}{1-2}$）结点的二叉树
- 每个结点都必有2个子树，且只有**最后一层**有叶子结点
- 按层序从1开始编号，则结点 $i$ 的左孩子为$2i$，右孩子为$2i+1$；结点 $j$ 的父节点为$\lfloor \frac{j}{2}\rfloor$

#### 完全二叉树

- 可以比满二叉树少一些结点，但所有结点按层序编号后要能与满二叉树一一对应
- 只有最后两层可能有叶子结点（如果倒数第二层有叶子节点，一定是最右的结点）
- 最多只有一个度为1的结点

![image-20220923095920868](C:\Users\18372\AppData\Roaming\Typora\typora-user-images\image-20220923095920868.png)

#### 二叉排序树

- 首先是棵二叉树
- 结点的**左子树**上所有结点的val都**小于**结点的val
- 结点的**右子树**上所有结点的val都**大于**结点的val
- 左右子树又各是一棵而二叉排序树

#### 平衡二叉树

- 首先是棵二叉树

- 任一结点的左子树和右子树的深度之差不超过1
- 如果一棵二叉排序树是平衡的，则搜索效率更高

### 3.4 二叉树的存储结构

#### 二叉树的顺序存储

```c++
#define MaxSize 100
struct TreeNode{
	ElemType value;
	bool isEmpty;
};
TreeNode t[MaxSize]
```

- 只有完全二叉树能将结点编号和数组下标对应起来，即根据结点编号找到左孩子和右孩子
- 非完全二叉树也想应用同样的存储方式，就不能层序遍历依次编号，只能与完全二叉树的编号一一对应；相应的，数组中会因此出现一些空位。浪费最严重的情况是非完全二叉树退化为最右侧的一条链，此时虽然只有$i$个结点，仍需要长度为$2^i-1$的数组

#### 二叉树的链式存储

```c++
typedef struct BiTNode{
	ElemType data;
	struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

n个结点的二叉链表共有$n+1$个空链域

### 3.5 二叉树的遍历

#### 先序遍历

根-左-右

```c++
void PreOrder(BiTree T){
	if(T!=NULL){
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
	}
}
```

#### 中序遍历

左-根-右

```c++
void InOrder(BiTree T){
	if(T!=NULL){
        PreOrder(T->lchild);
		visit(T);
		PreOrder(T->rchild);
	}
}
```

#### 后序遍历

左-右-根

```c++
void PostOrder(BiTree T){
	if(T!=NULL){
        PostOrder(T->lchild);
		PreOrder(T->rchild);
        visit(T);
	}
}
```

#### 层序遍历

```C++
void LevelOrder(BiTree T){
    LinkQueue(Q);
    InitQueue(Q);
    BiTree* p;
    EnQueue(T); //根节点入队
    while(!Q.isempty()){
        DeQueue(Q, p); //队首结点出队
        visit(p); //访问结点
        if(p->lchild!=NULL){
            EnQueue(Q, p->lchild);
        }
        if(p->rchild!=NULL){
            EnQueue(Q, p->rchild);
        }
    }
}
```

### 3.6 二叉树的构造

- 若只给出一棵二叉树的前序/中序/后序/层序中的其中一种序列，那么无法唯一确定一棵二叉树。
- 必须是中序遍历序列+其他三种中的任意一种，才能唯一确定一棵二叉树

