# 0x05 树与二叉树

## 一、基本术语

- 空树：结点数为0的树
- 非空树
  - 有且仅有一个根节点
  - 没有后继的结点称为叶子结点
  - 有后继的结点称为分支节点
  - 除根节点外，每个结点有且仅有一个前驱
- 两个结点之间的路径：从上往下
- 路径长度：路径经过了几条边
- 树的路径长度：从根结点出发到各个结点的路径长度之**和**

- 结点的层次（深度）——从上往下数（从1开始，根结点的深度是1）
- 结点的高度——从下往上数（从1开始，叶子结点的高度是1）
- 树的高度/深度——总共多少层
- 结点的度——有几个孩子
- 有序树——各子树从左到右是有顺序的，互换会影响含义
- 无序树——各子树无顺序，可以互换

## 二、树的性质

- 结点数=度数+1
- 树的度——各结点的度的最大值
- m叉树——每个结点**最多**只能有m个孩子的树

| 度为m的树                       | m叉树                         |
| ------------------------------- | ----------------------------- |
| 任意结点的度≤m（最多m个孩子）   | 任意结点的度≤m（最多m个孩子） |
| 至少有一个结点度=m（有m个孩子） | 允许所有结点的度都＜m         |
| 一定是非空树，至少有m+1个结点   | 可以是空树                    |

| 高度为h、度为m的树    | 高度为h的m叉树                                               |
| --------------------- | ------------------------------------------------------------ |
| **至少**有h+m-1个结点 | **至多**有$\frac{m^h-1}{m-1}$个结点（$=m^0+m^1+m^2+...$）<br>**至少**有h个结点 |

- 具有n个结点的m叉树的最小高度为$\lceil \log_m{(n(m-1)+1)}\rceil$

  - 推导：

  $$
  \begin{align}
  &\frac{m^{h-1}-1}{m-1}<n≤\frac{m^h-1}{m-1}\\
  &\Rightarrow m^{h-1}<n(m-1)+1≤mh\\
  &\Rightarrow h-1<\log_m{(n(m-1)+1)}≤h\\
  &\Rightarrow h_{min}=\lceil\log_m({n(m-1)+1)}\rceil&
  \end{align}
  $$

## 三、 二叉树

### 3.1 二叉树的基本特点

#### 二叉树

- 空二叉树，n=0
- 由一个根节点、左子树、右子树构成，左子树、右子树又分别是二叉树

#### 二叉树的特点

- 每个结点至多有两棵子树
- 左右子树不能颠倒（有序树）

#### 二叉树与度为2的有序树的区别

- 度为2的有序树至少有3个结点，而二叉树可以有2个、1个甚至0个结点

### 3.2 二叉树的性质

1. 设非空二叉树中共有$n$个结点，度为0、1、2的结点个数分别为$n_0$、$n_1$、$n_2$，则
   - $n_0=n_2+1$。（1个二分支结点能长出2个叶子，3个二分支结点能长出4个叶子……）
   - $n=n_0+n_1+n_2$
   - $n=n_1+2n_2+1$（$总度数=n_1+2n_2$）
2. 二叉树的第$i$层至多有$2^{i-1}$个结点
3. 高度为$h$的二叉树至多有$2^h-1$个结点（满二叉树的情况）
4. 具有$n$个结点的完全二叉树的高度$h$为$\lceil\log_2{n+1}\rceil$或$\lfloor \log_2{n}\rfloor$

### 3.3 特殊的二叉树

#### 做题常用

- 完全二叉树第 i 层有 m 个叶子结点——当第 i 层是最后一层时结点总数最少，当第 i 层是倒数第二层时结点总数最多
- 完全二叉树共有 m 个叶子结点——当倒数第二层的最左侧的叶子结点有一个左孩子时（这不会改变叶子结点总数），结点总数最多；反之最少。（或通过度数与结点数的关系分析）
- 已知一棵有2011个结点的树，其叶节点个数是116，该树对应的二叉树中无右孩子的结点个数是——这题考点是树转二叉树，左孩子右兄弟。树要构造最特殊的，即一条链的末尾接116个孩子结点。按左孩子右兄弟转为二叉树后变成一条中间有转折的链，前1895个结点无右孩子，链的最末尾结点也无右孩子。故答案为1895+1=1896

#### 满二叉树

- 一棵高为$h$，且含有$2^h-1$个（$2^0+2^1+...+2^h=\frac{1-2^h}{1-2}$）结点的二叉树
- 每个结点都必有2个子树，且只有**最后一层**有叶子结点
- 按层序从1开始编号，则结点 $i$ 的左孩子为$2i$，右孩子为$2i+1$；结点 $j$ 的父节点为$\lfloor \frac{j}{2}\rfloor$

#### 完全二叉树

- 可以比满二叉树少一些结点，但所有结点按层序编号后要能与满二叉树一一对应
- 只有最后两层可能有叶子结点（如果倒数第二层有叶子节点，一定是最右的结点）
- 最多只有一个度为1的结点

![image-20220923095920868](C:\Users\18372\AppData\Roaming\Typora\typora-user-images\image-20220923095920868.png)

#### 二叉排序树

- 首先是棵二叉树
- 结点的**左子树**上所有结点的val都**小于**结点的val
- 结点的**右子树**上所有结点的val都**大于**结点的val
- 左右子树又各是一棵而二叉排序树

#### 平衡二叉树

- 首先是棵二叉树

- 任一结点的左子树和右子树的深度之差不超过1
- 如果一棵二叉排序树是平衡的，则搜索效率更高

### 3.4 二叉树的存储结构

#### 二叉树的顺序存储

```c++
#define MaxSize 100
struct TreeNode{
	ElemType value;
	bool isEmpty;
};
TreeNode t[MaxSize]
```

- 只有完全二叉树能将结点编号和数组下标对应起来，即根据结点编号找到左孩子和右孩子
- 非完全二叉树也想应用同样的存储方式，就不能层序遍历依次编号，只能与完全二叉树的编号一一对应；相应的，数组中会因此出现一些空位。浪费最严重的情况是非完全二叉树退化为最右侧的一条链，此时虽然只有$i$个结点，仍需要长度为$2^i-1$的数组

#### 二叉树的链式存储

```c++
typedef struct BiTNode{
	ElemType data;
	struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

n个结点的二叉链表共有$n+1$个空链域

### 3.5 二叉树的遍历

#### 先序遍历

根-左-右

```c++
void PreOrder(BiTree T){
	if(T!=NULL){
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
	}
}
```

#### 中序遍历

左-根-右

```c++
void InOrder(BiTree T){
	if(T!=NULL){
        PreOrder(T->lchild);
		visit(T);
		PreOrder(T->rchild);
	}
}
```

#### 后序遍历

左-右-根

```c++
void PostOrder(BiTree T){
	if(T!=NULL){
        PostOrder(T->lchild);
		PreOrder(T->rchild);
        visit(T);
	}
}
```

#### 层序遍历

```C++
void LevelOrder(BiTree T){
    LinkQueue(Q);
    InitQueue(Q);
    BiTree* p;
    EnQueue(T); //根节点入队
    while(!Q.isempty()){
        DeQueue(Q, p); //队首结点出队
        visit(p); //访问结点
        if(p->lchild!=NULL){
            EnQueue(Q, p->lchild);
        }
        if(p->rchild!=NULL){
            EnQueue(Q, p->rchild);
        }
    }
}
```

### 3.6 二叉树的构造

- 若只给出一棵二叉树的前序/中序/后序/层序中的其中一种序列，那么无法唯一确定一棵二叉树。
- 必须是中序遍历序列+其他三种中的任意一种，才能唯一确定一棵二叉树

## 四、线索二叉树

### 4.1 基本概念

线索二叉树的“前驱”和“后继”是针对二叉树的中序遍历序列而言的，不是逻辑结构上的“前驱”和“后继”。

用**二叉链表**构造二叉树时，n个结点会产生n+1个空链域。线索二叉树利用这些空链域来保存“前驱”和“后继”的信息。

- 当左孩子指针为空时，使它指向前驱结点（前驱线索）
- 当右孩子指针为空时，使它指向后继结点（后继线索）

```c++
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *lchild, *rchild;
	int ltag, rtag; // 用于标记指针域指向的到底是孩子还是线索，0-孩子，1-线索
}ThreadNode, *ThreadTree;
```

### 4.2 二叉树的线索化

#### 中序线索化

```c++
ThreadNode *pre=NULL;
void CreateInThread(ThreadTree T){
    if(T!=NULL){
        InThread(T);
        pre->rchild = NULL; 
        //处理最后一个结点也就是中序遍历序列中最后一个元素的后继线索
        pre->rtag = 1;
    }
}
void InThread(ThreadTree T){
    if(T!=NULL){
        InThread(T->lchild);
        visit(T);
        InThread(T->rchild);
    }
}

void visit(ThreadNode* q){
    if(q->lchild == NULL){
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre!=NULL && pre->rchild==NULL){
        pre->rchild = q;
        pre->rtag = 1;
    }
    pre = q;
}
```

#### 先序线索化（！）

Q：若将中序线索化的代码照抄，只改变遍历顺序。先序遍历的顺序是根-左-右，假设pre指向根节点，q为正在访问的pre的左孩子。执行`visit(q)`，则q线索化后其前驱线索指向根节点，并令pre=q。然后会发生什么情况？

A：此时q已访问完毕，接下来访问的结点是q的左孩子，原本左孩子应为NULL，然而此时q的左指针已经被线索化，指向了q的根节点，然后将陷入死循环。

所以，应该相应修改代码，如下：

```c++
void PreThread(ThreadTree T){
	if(T!=NULL){
        visit(T);
        if (T->ltag == 0) 
            //当左指针未被线索化时，才尝试访问左孩子（实际上此时一定是NULL？）
            PreThread(T->lchild);
        PreThread(T->rchild);
    }
}
```

此外，先序线索化中访问的最后一个结点也是中序线索化中访问的最后一个结点（都是整棵树里最右边的那个结点），所以对它的处理方式相同：

```c++
void CreatePreThread(ThreadTree T){
    if(T!=NULL){
        PreThread(T);
        pre->rchild = NULL; 
        //处理最后一个结点也就是先序遍历序列中最后一个元素的后继线索
        pre->rtag = 1;
    }
}
```

#### 后序线索化

直接照抄中序线索化的代码，只改变遍历顺序即可。

后序线索化不存在先序线索化的小坑，因为后序遍历是左-右-根，访问结点的左孩子发生在结点的左指针线索化之前。

然而，后序线索化中访问的最后一个结点是整棵树的根结点，处理方式不能和先序中序一样（因为确实有存在右孩子的可能），应当先做个判断：

```c++
void CreatePostThread(ThreadTree T){
    if(T!=NULL){
        PostThread(T);
        if(pre->rchild == NULL) 
            //如果确实没有右孩子，就线索化，虽然一样是NULL
        	pre->rtag = 1;
    }
}
```

#### 易错点总结

- 先序线索化中访问左指针的小坑
- 三种线索化中对最后一个访问结点的rchild和rtag的处理

### 4.3 线索二叉树找前驱/后继

#### 中序线索二叉树

- 中序后继：如果没有右子树，则`p->rchild`就是它的后继；如果有右子树，则右子树的最左边结点就是它的后继。

  ```c++
  //找以P为根结点的子树中最左边的结点，也就是这棵子树中第一个开始中序遍历的
  ThreadNode* FirstNode(ThreadNode *p){ 
  	if(p->ltag == 0) p = p->lchild;
      return p;
  }
  //找p的中序后继
  ThreadNode* InOrder(ThreadNode *p){
  	if(p->rtag == 0) //如果有右子树，后继是右子树的最左边结点
          return FirstNode(p->rchild);
      else
          return p->rchild;
  }
  ```

- 中序前驱：如果没有左子树，则`p->lchild`就是它的前驱；如果有左子树，则左子树的最右边结点就是它的前驱。

  ```c++
  //找以P为根结点的子树中最右边的结点，也就是这棵子树中最后一个中序遍历的
  ThreadNode* LastNode(ThreadNode *p){ 
  	if(p->rtag == 0) p = p->rchild;
      return p;
  }
  //找p的中序前驱
  ThreadNode* InOrder(ThreadNode *p){
  	if(p->rtag == 0) //如果有左子树，前驱是左子树的最右边结点
          return Node(p->rchild);
      else
          return p->lchild;
  }
  ```

#### 先序线索二叉树

- 先序后继：如果有左子树，则左子树就是它的后继；如果没有左子树，则右子树就是它的后继

- 先序前驱：对于先序遍历，当前结点的前驱不可能在它的子树中。如果没有左子树，则前驱线索`p->lchird`就是它的前驱；**如果有左子树，则不可能找到前驱**，除非从根结点开始重新遍历

  **改进：三叉链表，多一个指向父结点的指针**

  - 若p的父结点存在，且p是左孩子——前驱就是p的父结点。
  - 若p的父结点存在，且p是右孩子，p的左兄弟为空——前驱就是p的父结点。
  - 若p的父结点存在，且p是右孩子，p的左兄弟非空——以p的左兄弟为根节点的子树中，遵循以下原则找到最后一个结点：能向右走向右走，右边没路才向左走。最后的结点就是p的前驱。
  - 若p的父结点不存在——p是整棵树的根节点，没有前驱。

#### 后序线索二叉树

- 后序前驱：