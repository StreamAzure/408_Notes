# 0x07 查找

## 一、查找的基本概念

- 查找：在数据集合中寻找满足某种条件的数据元素的过程
- 查找表：用于查找的数据集合
- 关键字：**唯一**标识数据元素的数据项
- 静态查找表：只需要查找符合条件的数据元素
- 动态查找表：既要查找符合条件的数据元素，也要进行插入、删除操作
- 查找长度：需要比对关键字的次数
- 平均查找长度：所有查找过程中进行关键字的比较次数的平均值

## 二、顺序查找

- 0号位置存哨兵，即待查找的元素。然后倒序遍历

- 时间复杂度$O(n)$

- 对有序表的查找优化：当关键字大于（或小于）目标关键字时，查找失败。查找失败时ASL更少

  - 共n+1种查找失败的情况，因为在升序查找表中，对最后一个元素查找失败既可能是因为待查元素小于它也可能是因为大于它

- 查找判定树

  ![image-20220928091516697](assets/image-20220928091516697.png)

## 三、折半查找

#### 算法实现

```c++
//左闭右闭区间
int binary_search(SSTable L, ElemType key){
	int left = 0, right = L.length - 1, mid;
    while(low <= high){
        mid = (low+high)/2;
        if(L.elem[mid]==key) return mid;
        else if(L.elem[mid]>key) high = mid - 1;
        else low = mid + 1;
    }
    return -1;
}
```

#### 查找判定树

![image-20220928092542439](assets/image-20220928092542439.png)

绿色为成功结点，紫色为失败结点

- 折半查找的判定树中，若使用$mid = \lfloor(low+high)/2\rfloor$，则右子树结点数-左子树结点数=0或1
- 折半查找判定树一定是平衡二叉树
- 元素个数为n时，树高$h = \lceil log_2(n+1)\rceil$

#### 查找效率

时间复杂度$O(log_2n)$

一般情况下折半查找比顺序查找效率更优秀，但并不是任何情况下都更优秀。如极端情况下待查元素就在查找表中第一位，则顺序查找第一次就可以找到，而折半查找需要多次折半才能确定。

## 四、分块查找

#### 算法思想

特点：块内无序，块间有序

1. 根据块内元素的最大值建立块的索引表
2. 用折半查找找到待查元素可能所在的块
   - 情况一：待查元素恰好就是索引值——`a[mid] == val`时确定块的位置
   - 情况二：待查元素在表中存在，但不是索引值——当进行到`left==right`时有一次判定，此时`mid`所指的块就是`val`所在的块，但因为`val`不是该块的索引值，判定会失败，又因为`val<index`，会进行`right--`，而`left`还停留在原来的位置。因此最终折半查找结束时，`left`所指的块就是`val`所在的块。
   - 情况三：待查元素不在表中——最终折半查找结束时，`low`会超出索引表范围。
3. 块内再用顺序查找

#### 查找效率 

- 平均查找长度：设索引查找和块内查找的平均查找长度分别为$L_1$、$L_s$，则分块的平均查找长度为$ASL=L_1+L_s$
- 设长度为$n$的查找表被均分成$b$块，每块$s$个元素
  - 若对该查找表的块间、块内都采用顺序查找，则$L_1 = \frac{1+2+3+...+b}{b}=\frac{b+1}{2}$，$L_s=\frac{1+2+3+...+s}{b}=\frac{s+1}{2}$，$ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$，当$s=\sqrt{n}$时，ASL取得最小值$\sqrt{n}+1$
  - 若对该查找表的块间采用折半查找、块内采用顺序查找，则$L_1=\lceil\log_2{b+1}\rceil$，$L_2$不变，$ASL=L_1=\lceil\log_2{b+1}\rceil+\frac{s+1}{2}$

## 五、B树与B+树

#### 5.1 B树/多路平衡查找树

- B树就是把二叉查找树变成$m$叉查找树，既保留排序特性，也保留平衡特性（规定对于任何一个结点，其所有子树的高度都要相同）

- 在二叉查找树中，每个结点都用一个关键字把搜索区域切成了两部分；在m叉查找树中，一个结点可以包含$n$个关键字，从而把搜索范围切成$n+1$个部分，即该结点的分叉有$n+1$个。

  ![image-20220928102713346](assets/image-20220928102713346.png)

- B树中所有结点的孩子个数的最大值称为B树的阶。

- 所有的叶结点都出现在同一层，并且不带信息（即类似于失败结点）。

- 除根结点外的所有非叶结点至少有$\lceil m/2 \rceil$棵子树，即至少含有$\lceil m/2 \rceil-1$个关键字。

- **计算B树的高度时一般不包括叶子结点/失败结点**

- 含有n个关键字的m阶B树，最小高度、最大高度是多少？

  - 最小高度：让每个结点尽可能满，即每个结点有m-1个关键字，m个分叉，则有：
    $$
    (m-1)(m^0+m^1+m^2+...+m^{h-1})≥n
    $$

  - 最大高度：让各层分叉尽可能少，即根结点只有2个分叉，其他结点只有$\lceil m/2\rceil$个分叉

## 六、红黑树

## 七、散列查找

- 散列表，又称哈希表，是**一种数据结构**。数据元素的关键字与其存储地址直接相关
- 散列函数：将关键字转换为对应的存储地址
- 同义词：不同的关键字被映射到同一个地址，则称这些关键字为同义词
- 冲突：通过散列函数确定的地址中已经被存放了其他元素

### 6.1 散列函数效率评估

![image-20220930140225370](assets/image-20220930140225370.png)

查找长度：在散列查找中，一般不把与空指针比较的次数计算在内。所以，在上图中，查找关键字21的查找长度为0；查找关键词66的查找长度为4.

查找失败的平均查找长度：设每个关键字映射到这13个地址的概率都是相同的，则查找失败的平均查找长度=每个地址查找失败时的查找长度之和/地址数量，如图中的$ASL_{失败}$为：
$$
ASL_{失败}=\frac{4+2+2+1+2+1+7\times0}{13}=0.92
$$
装填因子$\alpha$：表中记录数/散列表长度，数值上=$ASL_{失败}$。



### 6.2 散列函数设计

#### 除留余数法

$H(key) = key \% p$，其中$p$为最接近散列表表长$m$但不超过$m$的**质数**。

#### 直接定址法

直接用关键字作为地址，或对关键字作线性运算后的结果作为地址

$H(key) = key$ 或 $H(key) = a*key+b$

适合的情况：关键字分布基本连续。（如学号）

若关键字分布不连续，会产生较多的空位，造成空间浪费。

#### 数字分析法

截取关键字中数码分布较均匀的若干位作为地址

如手机号中的手机尾号四位的分布较均匀，直接以后四位作为地址。

#### 平方取中法

取关键字平方值的中间几位作为散列地址

这种取法使得地址与关键字的每一位都有关，从而映射的地址较为均匀。

适合的情况：关键字的每位取值都不够均匀或均小于散列地址所需的位数。

### 6.3 冲突处理

#### 拉链法

在存在冲突的地址上增加一条链表，将映射到该地址的元素依次存放在链表中。

![image-20220930140225370](assets/image-20220930140225370.png)

#### 开放定址法

即可存放新表项的空间即对它的同义词表项开放，也对它的非同义词表项开放

##### **线性探测法**

$H(i) = (H(key)+d_i) \% p$， 其中$d_i = i$，从0开始。

当发生冲突时，记录这是该地址的第几次冲突，往后查找相邻的为空的地址存放。

若查找过程中又发生冲突，则继续向后查找。

存储：

- 线性探测法可能会使得元素存放的位置超出了散列函数能直接确定的位置。如表长为16，散列函数为$H(key)=key\%13$，则散列函数能直接确定的位置是0到12，然而线性探测法可能会使得元素存放在位置14.
- 线性探测法中，元素既可能与同义词发生冲突，也可能与非同义词发生冲突。

查找：

- 与拉链法不同，空位置的判断也算作一次关键字比对。
- 越早遇到空位，越早确定是否查找失败。（所以删除操作会做对应调整以满足这个要求）

删除：

- 直接删除元素留下空位可能会截断元素的查找路径，所以不留下空位，而是留下一个特定的删除标记，指示这里虽然为空，但是是被删除的结果，查找路径应该向后继续。
- 弊端：最坏情况下散列表中前n-1个元素全被删除了，待查找元素恰是散列表的第n个元素，但由于上述查找过程，仍需比对$n$次关键字才能查找成功。

查找效率分析：

- $ASL_{成功}$：直接依次代入散列表的各个元素，先通过哈希函数确定地址，再看比对次数即可。分母为元素总个数。

- $ASL_{失败}$：假设查找元素时映射的地址依次为0、1、2……p-1，对于每个地址，计算它最终能确定查找失败时的关键字比对次数。**分母为哈希函数确定的位置个数**。

缺点：

- 很容易造成同义词、非同义词的“聚集/堆积”现象，严重影响查找效率。
- 这是因为线性探测法每当发生冲突时再探测都是存放在某个连续的位置

##### **平方探测法**

$H(i) = (H(key)+d_i) \% p$， 其中 $i$ 为冲突次数，$d_i = 0^2, 1^2,-1^2,2^2,-2^2...k^2,-k^2$，其中 $k≤m/2$

对 $p$ 有要求：$p$ 必须是一个可以表示成 $ 4j+3$ 的素数

##### 伪随机序列法

$d_i$ 为一个伪随机序列

#### 再散列法

准备多个散列函数，当一个散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止。

