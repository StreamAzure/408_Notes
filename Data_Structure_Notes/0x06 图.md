# 0x06 图

## 一、图的基本概念

### 1.1 基本定义

- 图G由顶点集V和边集E构成
- |V|表示图G中顶点的个数（图的阶），|E|表示图G中边的条数
- 图不可能为空，至少包含若干个顶点。

- 无向图：边记为(v, w)
- 有向图：边记为<v,w>，也称v到w的弧，w是弧头，v是弧尾
- 简单图：不存在重复边；不存在顶点到自身的边

### 1.2 度

- 顶点的度：无向图中，顶点v的度是连接到该顶点的边的条数，记为TD(v)；有向图中，顶点v的度是它的入度和出度之和。
- 入度：以顶点v为终点的有向边的数目，记为ID(v)
- 出度：以顶点v为起点的有向边的数目，记为OD(v)
- 无向图中，度的和=2|E|
- 有向图中，入度之和=出度之和=|E|

### 1.3 路径

- 路径：顶点序列。
- 回路：第一个顶点和最后一个顶点相同的路径
- 简单路径：顶点不重复出现的路径
- 简单回路：除了第一个顶点和最后一个顶点外其他顶点不重复出现的回路
- 路径长度：路径上边的数目
- 顶点到顶点的距离：只记最短路径，若不存在路径，则记为∞

### 1.4 连通

- 连通：无向图中，存在由顶点v到顶点w的路径，则称w、v连通
- 强连通：有向图中，存在顶点v和顶点w往返路径（相互能抵达），则称w、v强连通
- 连通图：任意两个顶点都连通的无向图
  - n个顶点的连通图至少有n-1条边，非连通图至多有$C^2_{n-1}$条边
- 强连通图：任意两个顶点都强连通的有向图
  - n个顶点的强连通图至少有n条边（形成回路）

### 1.5 连通分量、生成树

- 设图$G=(V,E)$和图$G'=(V',E')$，若$V'$是$V$的子集、$E'$是$E$的子集，则$G'$是$G$的子图
- 生成子图：包含原图所有顶点的子图

- 连通分量：无向图中的极大（包含尽可能多的顶点和边）连通子图
- 强连通分量：有向图中的极大强连通子图

- 连通图的生成树：包含图中全部顶点的一个极小连通子图。
- 给生成树去掉一条边会变成非连通图；给生成树增加一条边会形成一个回路
- 生成森林：非连通图中的各连通分量的生成树

### 1.6 特殊形态的图

- 无向完全图：无向图中任意两个顶点之间都存在边，$|E|=C^2_{n}$
- 有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，$|E|=2C^2_n$
- 稀疏图、稠密图
- 树：不存在回路且连通的无向图，n个顶点的树，必有n-1条边
  - n个顶点的图，若|E|>n-1，则一定有回路

## 二、图的存储

### 2.1 邻接矩阵

#### 定义

即用一个二维数组表示顶点$i$到顶点$j$是否有直接相连的边，默认行标签为起点，列标签为终点

```c++
#define MaxVertexNum 100
typedef struct{
    char Vex[MaxVertexNUM];
    int Edge[MaxVertexNUM][MaxVertexNUM]; //1存在，0不存在
    int vexnum,arcnum; //顶点数、边数
} MGraph;
```

求度：无向图中，第 $i$ 个结点的度 = 第 $i$ 行或第 $i$ 列的**非零元素**个数；有向图中第 $i$ 个结点的度 = 第 $i$ 行、第 $i$ 列的**非零元素**个数之和

求入度： 第 $i$ 个结点的入度 = 第 $i$ 列的**非零元素**个数

求出度：第 $i$ 个结点的入度 = 第 $i$ 行的**非零元素**个数

#### 性能分析

空间复杂度：$O(n)+O(n^2)=O(|V|^2)$，只与顶点数有关

#### 性质

邻接矩阵A自乘$n次$次得到$A^n$，$A^n$中元素的含义是：$A^n[i][j]$表示从顶点 $i$ 到顶点 $j$ 的、长度为 $n$ 的路径的数量。 

### 2.2 邻接表

#### 定义

顺序+链式存储。

```c++
typedef struct VNode{
	VertexType data; //顶点的权值
    ArcNode *first; //从该顶点出发的第一条边
}VNode, AdjList[MaxVertexNum];

typedef struct ArcNode{
    int adjvex; //边的终点
    struct ArcNode *next; //从同一顶点出发的另一条边
}ArcNode;
```

#### 性能分析

无向图：每一条边都对应两个顶点，导致两个顶点都有这条边的数据，即每条边都有多一份冗余数据。故`ArcNode`链表中边结点的数量为$2|E|$，整体空间复杂度为$O(|V|+2|E|)$

有向图：无冗余，整体空间复杂度为$O(|V|+|E|)$

#### 邻接表和邻接矩阵的对比

|                  | 邻接表                                  | 邻接矩阵           |
| ---------------- | --------------------------------------- | ------------------ |
| 空间复杂度       | 无向图$O(|V|+2|E|)$，有向图$O(|V|+|E|)$ | $O(|V|^2)$         |
| 适合用于         | 存储稀疏图                              | 存储稠密图         |
| 表示方式         | 不唯一                                  | 唯一               |
| 计算度/出度/入度 | 计算有向图的度、入度不方便，其他很方便  | 必须遍历对应行或列 |
| 找相邻的边       | 找有向图的入边不方便，其他很方便        | 必须遍历对应行或列 |

### 2.3 十字链表、邻接多重表

#### 十字链表

十字链表用于存储有向图。

邻接表的一条链表存储的是一个顶点的多条出边，它的问题在于找入边不方便，那么只要再来一个方向的链表，存储一个顶点的多条入边即可，即十字链表

```c++
typedef struct VNode{
	VertexType data; //顶点的权值
    ArcNode *firstout; //从该顶点出发的第一条边
    ArcNode *firstin; //到达该顶点的第一条边
}VNode, AdjList[MaxVertexNum];

typedef struct ArcNode{
    int tailvex; //弧尾，该边的起点
    int headvex; //弧头，该边的终点
    int info; //边权
    struct ArcNode *hlink; //同样以headvex为终点的另一条边
    struct ArcNode *tlink; //同样以tailvex为起点的另一条边
}
```

空间复杂度：$O(|V|+|E|)$

找指定顶点的所有出边：从`firstout`开始沿着`tlink`往下找

找指定顶点的所有入边：从`firstin`开始沿着`hlink`往下找

#### 邻接多重表

边结构体定义和十字链表基本相同，区别仅在顶点结构体定义上。

```c++
typedef struct VNode{
	VertexType data; //顶点的权值
    ArcNode *firstedge; //与该顶点相连的第一条边
}VNode, AdjList[MaxVertexNum];

typedef struct ArcNode{
    int i; //该边的一端
    int j; //该边的另一端
    int info; //边权
    struct ArcNode *ilink; //与i相连的另一条边
    struct ArcNode *jlink; //与j相连的林一条边
}
```

空间复杂度：$O(|V|+|E|)$