---
title: 考研笔记-数据结构：0x06 图
date: 2022-10-10 23:04:23
categories:
- [计算机基础, 数据结构]
---

# 0x06 图

## 一、图的基本概念

### 1.1 基本定义

- 图G由顶点集V和边集E构成
- |V|表示图G中顶点的个数（图的阶），|E|表示图G中边的条数
- 图不可能为空，至少包含若干个顶点。

- 无向图：边记为(v, w)
- 有向图：边记为<v,w>，也称v到w的弧，w是弧头，v是弧尾
- 简单图：不存在重复边；不存在顶点到自身的边

### 1.2 度

- 顶点的度：无向图中，顶点v的度是连接到该顶点的边的条数，记为TD(v)；有向图中，顶点v的度是它的入度和出度之和。
- 入度：以顶点v为终点的有向边的数目，记为ID(v)
- 出度：以顶点v为起点的有向边的数目，记为OD(v)
- 无向图中，度的和=2|E|
- 有向图中，入度之和=出度之和=|E|

### 1.3 路径

- 路径：顶点序列。
- 回路：第一个顶点和最后一个顶点相同的路径
- 简单路径：顶点不重复出现的路径
- 简单回路：除了第一个顶点和最后一个顶点外其他顶点不重复出现的回路
- 路径长度：路径上边的数目
- 顶点到顶点的距离：只记最短路径，若不存在路径，则记为∞

### 1.4 连通

- 连通：无向图中，存在由顶点v到顶点w的路径，则称w、v连通
- 强连通：有向图中，存在顶点v和顶点w往返路径（相互能抵达），则称w、v强连通
- 连通图：任意两个顶点都连通的无向图
  - **n个顶点的连通图至少有n-1条边，非连通图至多有$C^2_{n-1}$条边**
- 强连通图：任意两个顶点都强连通的有向图
  - **n个顶点的强连通图至少有n条边（形成回路）**

### 1.5 连通分量、生成树

- 子图：设图$G=(V,E)$和图$G'=(V',E')$，若$V'$是$V$的子集、$E'$是$E$的子集，则$G'$是$G$的子图
- 生成子图：包含原图所有顶点的子图

- 连通分量：无向图中的极大（包含尽可能多的顶点和边）连通子图
- 强连通分量：有向图中的极大强连通子图

- 连通图的生成树：包含图中全部顶点的一个极小连通子图。
- 给生成树去掉一条边会变成非连通图；给生成树增加一条边会形成一个回路
- 生成森林：非连通图中的各连通分量的生成树

### 1.6 特殊形态的图

- 无向完全图：无向图中任意两个顶点之间都存在边，$|E|=C^2_{n}$
- 有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，$|E|=2C^2_n$
- 稀疏图、稠密图
- 树：不存在回路且连通的无向图，n个顶点的树，必有n-1条边
  - n个顶点的图，若|E|>n-1，则一定有回路

## 二、图的存储

### 2.1 邻接矩阵

#### 定义

即用一个二维数组表示顶点$i$到顶点$j$是否有直接相连的边，默认行标签为起点，列标签为终点

```c
#define MaxVertexNum 100
typedef struct{
    char Vex[MaxVertexNUM];
    int Edge[MaxVertexNUM][MaxVertexNUM]; //1存在，0不存在
    int vexnum,arcnum; //顶点数、边数
} MGraph;
```

求度：无向图中，第 $i$ 个结点的度 = 第 $i$ 行或第 $i$ 列的**非零元素**个数；有向图中第 $i$ 个结点的度 = 第 $i$ 行、第 $i$ 列的**非零元素**个数之和

求入度： 第 $i$ 个结点的入度 = 第 $i$ 列的**非零元素**个数

求出度：第 $i$ 个结点的入度 = 第 $i$ 行的**非零元素**个数

#### 性能分析

空间复杂度：$O(n)+O(n^2)=O(|V|^2)$，只与顶点数有关

#### 性质

邻接矩阵A自乘$n$次得到$A^n$，$A^n$中元素的含义是：$A^n[i][j]$表示从顶点 $i$ 到顶点 $j$ 的、长度为 $n$ 的路径的数量。 

### 2.2 邻接表

#### 定义

顺序+链式存储。

```c++
typedef struct VNode{
	VertexType data; //顶点的权值
    ArcNode *first; //从该顶点出发的第一条边
}VNode, AdjList[MaxVertexNum];

typedef struct ArcNode{
    int adjvex; //边的终点
    struct ArcNode *next; //从同一顶点出发的另一条边
}ArcNode;
```

#### 性能分析

无向图：每一条边都对应两个顶点，导致两个顶点都有这条边的数据，即每条边都有多一份冗余数据。故`ArcNode`链表中边结点的数量为$2|E|$，整体空间复杂度为$O(|V|+2|E|)$

有向图：无冗余，整体空间复杂度为$O(|V|+|E|)$

#### 邻接表和邻接矩阵的对比

|                  | 邻接表                                  | 邻接矩阵           |
| ---------------- | --------------------------------------- | ------------------ |
| 空间复杂度       | 无向图$O(|V|+2|E|)$，有向图$O(|V|+|E|)$ | $O(|V|^2)$         |
| 适合用于         | 存储稀疏图                              | 存储稠密图         |
| 表示方式         | 不唯一                                  | 唯一               |
| 计算度/出度/入度 | 计算有向图的度、入度不方便，其他很方便  | 必须遍历对应行或列 |
| 找相邻的边       | 找有向图的入边不方便，其他很方便        | 必须遍历对应行或列 |

### 2.3 十字链表、邻接多重表

#### 十字链表

十字链表用于存储有向图。

邻接表的一条链表存储的是一个顶点的多条出边，它的问题在于找入边不方便，那么只要再来一个方向的链表，存储一个顶点的多条入边即可，即十字链表

```c++
typedef struct VNode{
	VertexType data; //顶点的权值
    ArcNode *firstout; //从该顶点出发的第一条边
    ArcNode *firstin; //到达该顶点的第一条边
}VNode, AdjList[MaxVertexNum];

typedef struct ArcNode{
    int tailvex; //弧尾，该边的起点
    int headvex; //弧头，该边的终点
    int info; //边权
    struct ArcNode *hlink; //同样以headvex为终点的另一条边
    struct ArcNode *tlink; //同样以tailvex为起点的另一条边
}
```

空间复杂度：$O(|V|+|E|)$

找指定顶点的所有出边：从`firstout`开始沿着`tlink`往下找

找指定顶点的所有入边：从`firstin`开始沿着`hlink`往下找

#### 邻接多重表

边结构体定义和十字链表基本相同，区别仅在顶点结构体定义上。

```c++
typedef struct VNode{
	VertexType data; //顶点的权值
    ArcNode *firstedge; //与该顶点相连的第一条边
}VNode, AdjList[MaxVertexNum];

typedef struct ArcNode{
    int i; //该边的一端
    int j; //该边的另一端
    int info; //边权
    struct ArcNode *ilink; //与i相连的另一条边
    struct ArcNode *jlink; //与j相连的林一条边
}
```

空间复杂度：$O(|V|+|E|)$

## 三、图的基本操作

- `Adjacent(G, x, y)`：判断图G是否存在边<x,y>或(x,y)
  - 邻接矩阵：$O(|V|)$（需要遍历一整行或一整列）
  - 邻接表：$O(1)到O(|V|)$（最多的情况下一个顶点上连接了图里的所有边）
- `Neighbors(G, x)`：列出图中与结点x邻接的边
  - 邻接矩阵：$O(|V|)$（需要遍历一整行或一整列）
  - 邻接表：出边：$O(1)到O(|V|)$；入边：$O(|E|)$，需要遍历完所有顶点的所有边链表，即遍历所有边
- 在图G中插入顶点X
- 在图G中删除顶点X
- 添加无向边(x,y)/有向边<x,y>（若不存在）
- 删除无向边(x,y)/有向边<x,y>（若存在）
- 求图G中顶点x的第一个邻接点，若有则返回顶点号；若无或顶点x不存在，则返回-1
- 求图G中顶点x的邻接点y的下一个邻接点，若有则返回顶点号；若无或顶点x不存在，则返回-1
- 求图G中边<x,y>或(x,y)的权值
- 将图G中边<x,y>或(x,y)的权值设为v

## 四、图的遍历

### 4.1 广度优先遍历

```c++
bool visited[MAX_VERTEX_NUM];

void bfs(Graph G, int v){
	visit(v);
    visited[v] = true;
    Enqueue(Q, v);
    while(!isEmpty(Q)){
        DeQueue(Q, v);
        for(w = FirstNeighbor(G,v)); w >= 0; w = NextNeighbor(G, v, w)){
            if(!visted[w]){
                visit(w);
                visited[w] = true;
                Enqueue(Q, w);
            }
        }
    }
}
```

- 如果图G是非连通图，则无法遍历所有结点：检查`visited`数组即可，一次BFS后若仍有未访问的顶点，则继续BFS即可
- 对于无向图，调用BFS函数的次数=连通分量数
- 空间复杂度：队列最坏情况下长度为$O(|V|)$
- 时间复杂度：
  - 邻接矩阵：访问$|V|$个顶点需要$O(|V|)$的时间，查找每个顶点的所有邻接点都需要$O(|V|)$的时间，总的时间复杂度为$O(|V|^2)$
  - 邻接表：访问$|V|$个顶点需要$O(|V|)$的时间，探索每个顶点的邻接点需要$O(|E|)$的时间，总的时间复杂度为$O(|V|+|E|)$

- 广度优先生成树：图为连通图，则一次BFS可以得到一棵生成树
- 广度优先生成森林：如果图中存在多个连通分量，则多次BFS生成多棵树。

### 4.2 深度优先遍历

```c++
bool visited[MAX_VERTEX_NUM];

void DFSTraverse(Graph G){
    for(v=0; v<G.vexnum; v++){
        visited[v] = false;
    }
    for(v=0; v<G.vexnum; v++){
        if(!visited[v]) DFS(G,v);
    }
}

void DFS(Graph G, int v){
    visit(v);
    visited[v] = true;
    for(w = FirstNeighbor(G,v); w>=0; w=NextNeighbor(G, v, w)){
        if(!visited[w]){
            DFS(G, w);
        }
    }
}
```

- 空间复杂度：最坏情况下递归深度为$O(|V|)$（一条链）

- 时间复杂度：访问各顶点所需时间+探索各条边所需时间
  - 邻接矩阵：访问$|V|$个顶点需要$O(|V|)$的时间；查找每个顶点的邻接点都需要$O(|V|)$的时间，总的时间复杂度为$O(|V|^2)$
  - 邻接表：访问$|V|$个顶点需要$O(|V|)$的时间，探索每个顶点的邻接点需要$O(|E|)$的时间，总的时间复杂度为$O(|V|+|E|)$

## 五、最小生成树

### 5.1 并查集

#### 并查集的代码实现

```c++
void init(int fa[]){
    for(int i = 0; i<SIZE;i ++){
        fa[i] = -1;
    }
}
int find(it fa[], int x){
	while(fa[x]>=0)	x=fa[x];//循环找x的根结点
    return x;
}

void Union(int fa[], int root1, int root2){
    if(root1 == root2) return; //两个集合是同一个集合
    fa[root2] = root1; //一个带头大哥作为另一个带头大哥的小弟，两个帮派就合并到一起了
}
```

**时间复杂度分析**

Union操作只需要O(1)，而find操作最坏情况下是O(n)（一条链的形式）。n个独立元素合并为一个集合，最坏达到O(n^2)。

#### Union优化

即尽量让每次合并都是让小树（结点数少的）合并到大树上（结点数多的），而不是反过来

```c++
void Union(int fa[], int root1, int root2){
    if(root1 == root2) return;
    //注意因为初始化时每个独立结点的值均为-1，所以fa[x]=-k表示以x为根的树共有k个结点
    if(fa[root2] > fa[root1]){ //root2为根的树结点数更少
        fa[root1] += fa[root2]; 
        fa[root2] = root1;	//小树合并到大树上
    }else{
        fa[root2] += fa[root1]; //root1为根的树结点数更少
        fa[root1] = root2; //小树合并到大树上
    }
}
```

**时间复杂度分析**

find操作的最坏时间复杂度优化到了$O(log_2n)$，故n个独立元素合并为一个集合的时间复杂度为$O(n\log_2{n})$

#### 压缩路径

每次进行查找操作时，都顺便把路径上的全部结点挂到根结点上

```c++
int find(int [], int x){
	int root = x;
    while(fa[root] > 0) root = fa[root]; //循环找根
    while(x != root){ //再走一遍查找路径
        int t = fa[x];
        fa[x] = root; //把当前经过的结点挂到根结点上
        x = t;
    }
    return root;
}
```

find操作的最坏时间复杂度优化到了$O(\alpha(n))$，$\alpha(n)$是一个增长很缓慢的函数，故n个独立元素合并为一个集合的时间复杂度为$O(n\alpha(n))$

### 5.2 Prim算法/普利姆算法

- 从某个顶点开始构建生成树；每次都将与现有树相连的、代价最小的新顶点纳入生成树，直到纳入所有顶点
- 时间复杂度$O|V|^2$，适用于边稠密图

```c
int Graph[Max][Max]; //邻接矩阵存图

void prime(int n) {
    int lowcost[Max];
    int i, j, min1, minid, sum = 0;
    for (i = 2; i <= n; i++) { //顶点1已经默认为起点了
        lowcost[i] = Graph[1][i]; //与顶点1相邻的边的权值
    }
    mst[1] = 0;//将顶点1加入MST
    for (i = 2; i <= n; i++) {
        min1 = MaxCost;
        minid = 0;
        for (j = 2; j <= n; j++) { //找未在MST中的、且相连边权值最小的顶点
            if (lowcost[j] < min1 && lowcost[j] != 0) {
                min1 = lowcost[j];
            }
        }
        lowcost[minid] = 0; //将找到的新顶点加入MST
        for (j = 2; j <= n; j++) { //更新lowcost数组
            if (Graph[minid][j] < lowcost[j]) {
                lowcost[j] = Graph[minid][j];
            }
        }
    }
}
```

### 5.3 Kruskal算法/克鲁斯卡尔算法

- 每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的不选），直到所有顶点都连通
- 时间复杂度$O(|E|log|E|)$，适用于边稀疏图

## 六、最短路问题

### 6.1 BFS算法

- 只适合用于边权相等的带权图/无权图
- 时间复杂度$O(|V|^2)$（邻接矩阵）/ $O(|V|+|E|)$（邻接表）
- 不适用负权图

### 6.2 Dijkstra算法

- 时间复杂度$O(|V|^2)$
- 不适用于负权图

### 6.3 Floyd算法

- 时间复杂度$O(|V|^3)$
- 空间复杂度$O(|V|^2)$
- 负权图能用，但不能有负权回路

```c++
for(int i = 1; i<=n; i++){
    for(int j = 1; j<= n; j++){
        for(int k = 1; k<=n; k++){
            if(graph[i][k]+graph[k][j] <= graph[i][j]){
                graph[i][j] = graph[i][k]+graph[k][j];
            }
        }
    }
}
```

## 七、有向无环图 DAG

### 7.1 表达式描述

- 用有向无环图存储表达式：可以有重边

  方法是：将运算符生效次序编号，操作数放在第一层，直接对操作数进行运算的放在第二层，依赖于第二层运算的运算符放在第三层……以此类推，然后看哪些操作符的运算对象有重复，有重复的合并为一个运算符，原本的入边也都入到这个结点上。从下往上操作，最后得到一个DAG（可能有重边）

### 7.2 拓扑排序

- AOV网：以顶点表示活动，以有向边描述活动次序的**有向无环图**。

- 拓扑排序：由一个DAG的顶点组成的序列，每个顶点出现且只出现一次，且序列中若顶点A排在顶点B的前面，则不存在顶点B到顶点A的**路径**.

  若要求一边执行一边顺序输出，则需要用到栈。基本思路是：先将所有入度为0的顶点入栈。当栈不空时，栈顶元素出栈并输出，同时将它的出边指向的其他顶点的入度-1，并将入度减为0的顶点入栈，重复上述过程直到栈空。

  **回路判断**：若最后输出的顶点个数小于总的顶点个数，说明有向图中有回路。

- 逆拓扑排序：直接DFS即可，注意是搜完了这个点的所有边之后才输出这个点。

  ```c++
  void DFSTraverse(Graph G){
  	for(int v = 0; v < G.vexnum; v++){
  		visited[v] = false;
  	}
      for(int v =0; v < G.vexnum; v++){
          if(!visited[v]) dfs(G,v);
      }
  }
  void dfs(Graph G, int v){
      visited[v] = true;
      for( int w = firstNeighbor(G, v); w>=0; w = nextNeighbor(G,v,w))
          if(!visited[w]){
              dfs(G, w);
          }
      print(v);
  }
  ```

  **回路判断**：将结点的访问状态设为三种：0表示未访问；1表示已搜完所有的边，已经输出；-1表示正在访问。则DFS中若搜到了访问状态为-1的顶点，说明有向图中有回路。

## 八、关键路径

- AOE网：有边权的AOV网，即也是有向无环图

- 关键路径：从源点到汇点的路径中，具有最大路径长度的路径为**关键路径**。注意是路径不是弧，不要看成一条边的边权了

- 关键活动：关键路径上的活动（活动是在边上的，事件才是在顶点上的）

  - 若关键活动耗时增加，则整个工程的工期将延长
  - 若只有一条关键路径，那么缩短关键活动的时间，可以缩短整个工程的工期
  - 若存在多条关键路径，那么只有**缩短多条关键路径中共同的关键活动的耗时**，才能缩短整个工程的工期。
  - 缩短到一定程度时，关键活动可能会变成非关键活动

- 求关键路径：

  1. 求所有事件的最早发生时间（即假设拓扑序最开头的那个事件立即发生，往后推其他事件的发生时间）。若一个事件存在多个前驱事件，则取最大值。
  2. 求所有事件的最晚发生时间（即给拓扑序最末尾的那个事件一个ddl，往前推其他事件的ddl）。若一个事件存在多个后继事件，则取最小值。
  3. 求所有活动的最早发生时间（一个结点的事件发生后才能开始走边/进行活动，由于一条边的两端顶点都是唯一的，所以不存在取最大值最小值的问题，但是，由于追求最早发生时间，所以结点事件发生后活动立即开始）
  4. 求所有活动的最晚发生时间（活动可以在结点事件发生之后开始，只要赶得上下一事件的最晚发生时间即可。相当于老师布置作业（事件A）的时间——你开始写作业（活动开始）的时间——作业截止（事件B）时间，只要卡在截止时间前写完就行，不需要老师一布置作业就立即开始写）
  5. 求所有活动的时间余量，最晚发生时间-最早发生时间
  6. **时间余量为0的活动为关键活动**

  