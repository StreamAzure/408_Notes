# 0x02 进程管理

## 一、进程

### 1.1 进程的概念

- 程序是静态的，是一系列指令的集合。进程是动态的，是程序的一次执行过程。
- **进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

- PID：操作系统为进程分配的唯一标识

- PCB：一个存储进程各信息的数据结构，**是进程存在的唯一标志**
  - PID
  - 进程所属用户ID
  - 资源分配情况
  - 进程运行情况
- 进程实体/进程映像
  - PCB
  - 程序段：程序的代码
  - 数据段：运行过程中产生的各种数据

### 1.2 进程的特征

- 动态性
  - 进程是程序的一次执行过程，是动态地产生、变化和消亡的
- 并发性
  - 内存中有多个进程实体，各进程可并发执行
- 独立性
  - 进程是能独立运行、独立获得资源、独立接受调度的基本单位
- 异步性
  - 各进程按各自独立的、不可预知的速度向前推进
  - 操作系统要提供“进程同步机制”来解决异步问题
- 结构性
  - 每个进程都会配置一个PCB
  - 进程由程序段、数据段、PCB组成

### 1.3 进程的状态

- 运行态：进程正在处理机上运行
- 就绪态：进程仅缺少处理机
- 阻塞态：进程需要其他资源（除了处理机）或等待某一事件
- 创建态：进程正在被创建。如果进程所需的资源尚不能得到满足，则创建工作尚未完成，进程会停留在创建态
- 结束态：进程需要结束运行时，系统首先将该进程置为结束态，然后进一步处理资源释放和回收等工作

一个进程从运行态变成阻塞态是主动的行为，从阻塞态变成就绪态是被动的行为，需要其他相关进程的协助。

### 1.4 进程的组织

#### 进程控制块（PCB）

- PCB常驻内存，任意时刻都可以存取

- PCB通常包含的内容:

  | 进程描述信息 | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
  | ------------ | ------------------ | ------------ | -------------- |
  | 进程标识符   | 进程当前状态       | 代码段指针   | 通用寄存器值   |
  | 用户标识符   | 进程优先级         | 数据段指针   | 地址寄存器值   |
  |              | 代码运行入口地址   | 堆栈段指针   | 控制寄存器值   |
  |              | 程序的外存地址     | 文件描述符   | 标志寄存器值   |
  |              | 进入内存时间       | 键盘         | 状态字         |
  |              | 处理机占用时间     | 鼠标         |                |
  |              | 信号量使用         |              |                |

- PCB的组织方式

  - 链接方式：将同一状态的PCB链接成一个队列，不同状态对应不同的队列
  - 索引方式：将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表

#### 程序段

程序段是能被进程调度程序调度到CPU执行的程序代码段。程序可被多个进程共享

#### 数据段

可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果

### 1.5 进程控制

#### 进程的创建

允许一个进程创建另一个进程，创建者称为父进程，被创建者称为子进程

子进程可以继承父进程所拥有的资源

- 当子进程被撤销时应归还资源

父进程被撤销时，通常也会同时撤销其所有的子进程

创建原语：

1. 为新进程分配一个唯一的PID，并申请一个空白PCB，若PCB申请失败，则创建失败
2. 为进程分配其运行所需的资源，如内存、文件、I/O和CPU时间等
3. 初始化PCB，主要包括初始化标志信息，初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行

#### 进程的终止

引起进程终止的事件有：

- 正常结束：表示进程的任务已完成并准备退出运行
- 异常结束：进程在运行时，发生了某种异常事件，使程序无法继续运行
- 外界干预：应外界的请求而终止运行

终止原语：

1. 根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态
2. 若被终止进程处于运行态，立即终止运行，将处理机资源分配给其他进程
3. 若该进程还有子孙进程，将其所有子孙进程终止
4. 将该进程拥有的全部资源，或归还给父进程，或归还给操作系统
5. 将该PCB从所在队列（链表）中删除

#### 进程的阻塞和唤醒

只有处于运行态的进程，才可能将自己转为阻塞态。

阻塞（Block）原语：

1. 找到将要被阻塞进程的PID对应的PCB
2. 若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行
3. 把该PCB插入相应时间的等待队列，将处理机资源调度给其他就绪进程

唤醒（Wakeup）原语（由相关进程调用）：

1. 在该事件的等待队列中找到相应进程的PCB
2. 将其从等待队列中移出，并置其状态为就绪态
3. 把该PCB插入就绪队列，等待调度程序调度

只要有进程调用了阻塞原语，就必须在与之合作的或其他相关的进程中安排一条相应的唤醒原语。否则，阻塞进程无法被唤醒，会永久处于阻塞状态。

### 1.6 进程的通信

#### 共享存储

进程之间使用一块可直接访问的共享空间，通过对这块空间的读写操作实现进程之间的信息交换。

需要使用同步互斥工具对共享空间的写/读进行控制

低级方式的共享：基于数据结构的共享

高级方式的共享：基于存储区的共享

#### 消息传递

消息传递是当前应用最广泛的进程间通信机制。

进程间的数据交换以格式化的消息（Message）为单位。

- 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息
- 间接通信方式：发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱。

#### 管道通信

管道通信是消息传递的一种特殊方式。写进程以字符流形式将大量数据写入管道，而读进程从管道中读数据。

管道：连接一个读进程和一个写进程以实现它们之间的通信的一个**共享文件**，与一般文件有所不同，管道可以克服文件进行通信的两个问题：

- 限制管道的大小。管道是个固定大小的缓冲区，在Linux中大小为4KB，当管道满时写进程被阻塞直到管道数据被读取腾出空间。
- 读进程可能工作得比写进程快。当管道已空时，读进程默认被阻塞，等待数据被写入。

管道通信是半双工通信。

与共享存储方式不同，管道通信不会发生读写冲突，因为写进程必定先把缓冲区写满，才会让读进程读；而在读进程眼中，只要缓冲区有数据，它就可以读。

### 1.7 线程和多线程模型

#### 线程的概念

引入线程：减小程序在并发执行时的开销，提高操作系统的并发性能。

线程可以理解为“轻量级进程”，是基本的CPU执行单元，也是程序执行流的最小单元，也是系统独立调度和分派的基本单位。

线程的组成：线程ID、程序计数器、寄存器集合、堆栈。

线程自己不拥有系统资源，但与同属于同一个进程的其他线程一起共享进程所拥有的资源。

线程之间的制约，使线程在运行中呈现间断性

线程有就绪、阻塞、运行三种基本状态

|              | 线程                                                         | 进程                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 调度         | 是独立调度的基本单位，且线程切换代价远低于进程；属于不同进程的线程之间切换会引起进程切换 | 在传统操作系统中，进程是独立调度的基本单位，每次调度都要进行上下文切换，开销大 |
| 并发         | 进程与进程之间可并发执行，线程与线程之间也可并发执行，无论是否属于同一进程 | 进程与进程之间可并发执行                                     |
| 资源         | 不拥有系统资源（只有一点必不可少、能保证独立运行的资源），但可以访问其所属进程的资源。**同一进程的所有线程都有相同的地址空间** | 进程是系统中拥有资源的基本单位                               |
| 独立性       | 同一进程的各个线程共享进程的地址空间和资源。一个进程的线程对其他进程不可见 | 每个进程都拥有独立的地址空间和资源，除了共享全局变量以外，不允许其他进程访问 |
| 系统开销     | 线程的创建、撤销、切换的开销都很小；同一进程的线程之间同步与通信非常容易实现，甚至无需操作系统的干预 | 进程的创建、撤销需要系统分配/回收PCB及其他资源等；进程切换需要切换上下文内容，开销大 |
| 多处理机系统 | 同属于同一个进程的多个线程可以分散在不同处理机上运行         | 不管有多少处理机，进程都只能在一个处理机上运行               |

#### 线程的属性

- 线程都具有唯一标识符和对应线程控制块，线程控制块记录线程执行的寄存器和栈等现场状态
- 不同的线程可以执行相同的程序
- 同一进程中的各个线程共享该进程所拥有的资源
- 线程是处理机的独立调度单位

#### 线程的状态与转换

执行状态、就绪状态、阻塞状态，与进程基本一致

#### 线程的组织与控制

- 线程控制块TCB
  - 线程标识符、一组寄存器、线程运行状态、优先级、线程专有存储区、堆栈指针
  - 由于地址空间共享，一个线程可以读写甚至清除另一个线程的堆栈
- 线程的创建
  - 操作系统中有用于创建线程和终止线程的函数（或系统调用）
  - 用户程序启动时，由一个称为“初始化线程”的线程执行创建新线程的工作。
- 线程的终止
  - 有些线程（如系统线程）一旦被建立而不会被终止
  - 线程被终止后不会立即释放占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，资源才可用
  - 被终止但尚未释放资源的线程仍可被其他线程调用，重新恢复运行

#### 线程的实现方式

- **用户级线程（ULT）**

  线程管理工作：由应用程序在用户空间中完成，内核意识不到线程的存在

  系统调度：仍以进程为单位进行

  优点：

  - 不同进程可以根据不同需要选择不同的线程调度算法

  - 线程切换不需要转换到内核空间，节省了模式切换的开销；

  - ULT的实现与操作系统平台无关

  缺点：

  - **一个线程执行系统调用时会导致其自身以及其他线程都被阻塞**
  - 不能发挥多处理机的优势，内核每次分配给一个进程的只有一个CPU，因此同一时间内进程中只有一个线程能执行

- **内核级线程（KLT）／内核支持的线程**

  线程管理工作：在内核空间内实现

  优点：

  - 如果进程中的一个线程被阻塞，内核可以调度该进程的其他线程占用处理机，也可运行其他进程中的线程
  - 能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行
  - 内核本身也可采用多线程基数，提高系统执行速度和效率

  缺点：

  - 同一进程中的进程切换，需要转到核心态进行，系统开销较大。因为用户进程的线程都是在用户态运行，而线程调度和管理在内核实现。

- **ULT和KLT的组合实现**

  即操作系统内核支持多个内核级线程的建立、调度和管理，也允许用户程序建立、调度和管理用户及线程。

  一些内核级线程对应多个用户级线程。同一进程中的多个线程可以同时在多处理机上并行执行，阻塞一个线程时不需要将整个进程阻塞，结合了KLT和ULT的优点，并能克服各自的不足。

  根据用户级线程和内核级线程连接方式的不同，有多种多线程模型：

  - 多对一模型
    - 将多个用户级线程映射到一个内核级线程。用户级线程运行在用户态，当线程需要访问内核时，才将其映射到一个内核级线程上，每次仅允许一个线程进行映射。
    - 优点：线程管理在用户空间进行，效率高
    - 缺点：如果一个线程在访问内核时发生阻塞，则阻塞整个进程；且任何时刻只有一个线程能访问内核，多个线程不能同时在多个处理机上运行
  - 一对一模型
    - 每个用户级线程映射到一个内核级线程
    - 优点：一个线程被阻塞后，允许调度另一个线程运行
    - 缺点：每创建一个用户线程，就要相应创建一个内核级线程，开销大
  - 多对多模型
    - 将n个用户线程映射到m个内核级线程上，且n≥m
    - 既克服了上述两种模型的缺点，又兼具两者的优点

## 二、处理机调度

